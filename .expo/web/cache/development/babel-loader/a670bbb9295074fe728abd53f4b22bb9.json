{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractFieldPathData = extractFieldPathData;\nexports.parseUpdateArgs = parseUpdateArgs;\nexports.parseSetOptions = parseSetOptions;\nexports.parseSnapshotArgs = parseSnapshotArgs;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _common = require(\"@react-native-firebase/app/lib/common\");\n\nvar _FirestoreFieldPath = _interopRequireWildcard(require(\"../FirestoreFieldPath\"));\n\nfunction extractFieldPathData(data, segmenets) {\n  if (!(0, _common.isObject)(data)) {\n    return undefined;\n  }\n\n  var pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\n\nfunction parseUpdateArgs(args) {\n  var data = {};\n\n  if (args.length === 1) {\n    if (!(0, _common.isObject)(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n\n    var _args = (0, _slicedToArray2.default)(args, 1);\n\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error('the update arguments must be either a single object argument, or equal numbers of key/value pairs.');\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n\n      if ((0, _common.isString)(key)) {\n        data[key] = value;\n      } else if (key instanceof _FirestoreFieldPath.default) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(\"argument at index \" + i + \" must be a string or FieldPath\");\n      }\n    }\n  }\n\n  return data;\n}\n\nfunction parseSetOptions(options) {\n  var out = {};\n\n  if ((0, _common.isUndefined)(options)) {\n    return out;\n  }\n\n  if (!(0, _common.isObject)(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if ((0, _common.hasOwnProperty)(options, 'merge') && (0, _common.hasOwnProperty)(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!(0, _common.isUndefined)(options.merge)) {\n    if (!(0, _common.isBoolean)(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!(0, _common.isUndefined)(options.mergeFields)) {\n    if (!(0, _common.isArray)(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (var i = 0; i < options.mergeFields.length; i++) {\n      var field = options.mergeFields[i];\n\n      if (!(0, _common.isString)(field) && !(field instanceof _FirestoreFieldPath.default)) {\n        throw new Error(\"'options.mergeFields' all fields must be of type string or FieldPath, but the value at index \" + i + \" was \" + typeof field);\n      }\n\n      var path = field;\n\n      if ((0, _common.isString)(path)) {\n        try {\n          path = (0, _FirestoreFieldPath.fromDotSeparatedString)(field);\n        } catch (e) {\n          throw new Error(\"'options.mergeFields' \" + e.message);\n        }\n      }\n\n      if (field instanceof _FirestoreFieldPath.default) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  var NOOP = function NOOP() {};\n\n  var snapshotListenOptions = {};\n  var callback = NOOP;\n  var onError = NOOP;\n  var onNext = NOOP;\n\n  if ((0, _common.isFunction)(args[0])) {\n    if ((0, _common.isFunction)(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      callback = args[0];\n    }\n  }\n\n  if ((0, _common.isObject)(args[0]) && args[0].includeMetadataChanges === undefined) {\n    if (args[0].error) {\n      onError = args[0].error;\n    }\n\n    if (args[0].next) {\n      onNext = args[0].next;\n    }\n  }\n\n  if ((0, _common.isObject)(args[0]) && args[0].includeMetadataChanges !== undefined) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges;\n\n    if ((0, _common.isFunction)(args[1])) {\n      if ((0, _common.isFunction)(args[2])) {\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        callback = args[1];\n      }\n    } else if ((0, _common.isObject)(args[1])) {\n      if ((0, _common.isFunction)(args[1].error)) {\n        onError = args[1].error;\n      }\n\n      if ((0, _common.isFunction)(args[1].next)) {\n        onNext = args[1].next;\n      }\n    }\n  }\n\n  if ((0, _common.hasOwnProperty)(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!(0, _common.isBoolean)(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!(0, _common.isFunction)(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!(0, _common.isFunction)(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return {\n    snapshotListenOptions: snapshotListenOptions,\n    callback: callback,\n    onNext: onNext,\n    onError: onError\n  };\n}","map":{"version":3,"sources":["C:/Program Files/nodejs/ComeClosely/node_modules/@react-native-firebase/firestore/lib/utils/index.js"],"names":["extractFieldPathData","data","segmenets","undefined","pathValue","length","slice","parseUpdateArgs","args","Error","i","key","value","FirestoreFieldPath","_toPath","parseSetOptions","options","out","merge","mergeFields","field","path","e","message","push","parseSnapshotArgs","NOOP","snapshotListenOptions","callback","onError","onNext","includeMetadataChanges","error","next"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  hasOwnProperty,\n  isArray,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\n\nexport function extractFieldPathData(data, segmenets) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\n\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(\n      'the update arguments must be either a single object argument, or equal numbers of key/value pairs.',\n    );\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\n          `'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`,\n        );\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && args[0].includeMetadataChanges === undefined) {\n    if (args[0].error) {\n      onError = args[0].error;\n    }\n    if (args[0].next) {\n      onNext = args[0].next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && args[0].includeMetadataChanges !== undefined) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isObject(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      if (isFunction(args[1].error)) {\n        onError = args[1].error;\n      }\n      if (isFunction(args[1].next)) {\n        onNext = args[1].next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return { snapshotListenOptions, callback, onNext, onError };\n}\n"]},"metadata":{},"sourceType":"script"}