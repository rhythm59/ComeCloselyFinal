{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _common = require(\"@react-native-firebase/app/lib/common\");\n\nvar _serialize = require(\"./utils/serialize\");\n\nvar _FirestoreFieldPath = require(\"./FirestoreFieldPath\");\n\nvar OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  in: 'IN'\n};\nvar INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true\n};\nvar DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n\nvar FirestoreQueryModifiers = function () {\n  function FirestoreQueryModifiers() {\n    (0, _classCallCheck2.default)(this, FirestoreQueryModifiers);\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  (0, _createClass2.default)(FirestoreQueryModifiers, [{\n    key: \"_copy\",\n    value: function _copy() {\n      var newInstance = new FirestoreQueryModifiers();\n      newInstance._limit = this._limit;\n      newInstance._limitToLast = this._limitToLast;\n      newInstance._filters = (0, _toConsumableArray2.default)(this._filters);\n      newInstance._orders = (0, _toConsumableArray2.default)(this._orders);\n      newInstance._type = this._type;\n      newInstance._startAt = this._startAt;\n      newInstance._startAfter = this._startAfter;\n      newInstance._endAt = this._endAt;\n      newInstance._endBefore = this._endBefore;\n      return newInstance;\n    }\n  }, {\n    key: \"setFieldsCursor\",\n    value: function setFieldsCursor(cursor, fields) {\n      this[\"_\" + cursor] = (0, _serialize.buildNativeArray)(fields);\n      return this;\n    }\n  }, {\n    key: \"hasStart\",\n    value: function hasStart() {\n      return !!(this._startAt || this._startAfter);\n    }\n  }, {\n    key: \"hasEnd\",\n    value: function hasEnd() {\n      return !!(this._endAt || this._endBefore);\n    }\n  }, {\n    key: \"asCollectionGroupQuery\",\n    value: function asCollectionGroupQuery() {\n      this._type = 'collectionGroup';\n      return this;\n    }\n  }, {\n    key: \"isCollectionGroupQuery\",\n    value: function isCollectionGroupQuery() {\n      return this._type === 'collectionGroup';\n    }\n  }, {\n    key: \"isValidLimit\",\n    value: function isValidLimit(limit) {\n      return !(0, _common.isNumber)(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      this._limitToLast = undefined;\n      this._limit = _limit;\n      return this;\n    }\n  }, {\n    key: \"isValidLimitToLast\",\n    value: function isValidLimitToLast(limit) {\n      return !(0, _common.isNumber)(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"validatelimitToLast\",\n    value: function validatelimitToLast() {\n      if (this._limitToLast) {\n        if (!this._orders.length) {\n          throw new Error('firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause');\n        }\n      }\n    }\n  }, {\n    key: \"limitToLast\",\n    value: function limitToLast(_limitToLast) {\n      this._limit = undefined;\n      this._limitToLast = _limitToLast;\n      return this;\n    }\n  }, {\n    key: \"isValidOperator\",\n    value: function isValidOperator(operator) {\n      return !!OPERATORS[operator];\n    }\n  }, {\n    key: \"isEqualOperator\",\n    value: function isEqualOperator(operator) {\n      return OPERATORS[operator] === 'EQUAL';\n    }\n  }, {\n    key: \"isInOperator\",\n    value: function isInOperator(operator) {\n      return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY';\n    }\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      var filter = {\n        fieldPath: fieldPath,\n        operator: OPERATORS[opStr],\n        value: (0, _serialize.generateNativeData)(value)\n      };\n      this._filters = this._filters.concat(filter);\n      return this;\n    }\n  }, {\n    key: \"validateWhere\",\n    value: function validateWhere() {\n      var hasInequality;\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        if (!INEQUALITY[filter.operator]) {\n          continue;\n        }\n\n        if (!hasInequality) {\n          hasInequality = filter;\n          continue;\n        }\n\n        if (INEQUALITY[filter.operator] && hasInequality) {\n          if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n            throw new Error(\"Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '\" + hasInequality.fieldPath._toPath() + \"' and '\" + filter.fieldPath._toPath() + \"'\");\n          }\n        }\n      }\n\n      var hasArrayContains;\n      var hasArrayContainsAny;\n      var hasIn;\n\n      for (var _i = 0; _i < this._filters.length; _i++) {\n        var _filter = this._filters[_i];\n\n        if (_filter.operator === OPERATORS['array-contains']) {\n          if (hasArrayContains) {\n            throw new Error('Invalid query. Queries only support a single array-contains filter.');\n          }\n\n          hasArrayContains = true;\n        }\n\n        if (_filter.operator === OPERATORS['array-contains-any']) {\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n          }\n\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\");\n          }\n\n          hasArrayContainsAny = true;\n        }\n\n        if (_filter.operator === OPERATORS.in) {\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n          }\n\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\");\n          }\n\n          hasIn = true;\n        }\n      }\n    }\n  }, {\n    key: \"isValidDirection\",\n    value: function isValidDirection(directionStr) {\n      return !!DIRECTIONS[directionStr.toLowerCase()];\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      var order = {\n        fieldPath: fieldPath._toPath(),\n        direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n      };\n      this._orders = this._orders.concat(order);\n      return this;\n    }\n  }, {\n    key: \"validateOrderBy\",\n    value: function validateOrderBy() {\n      if (this._orders.length > 1) {\n        var orders = this._orders.map(function ($) {\n          return $.fieldPath;\n        });\n\n        var set = new Set(orders);\n\n        if (set.size !== orders.length) {\n          throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n        }\n      }\n\n      if (this._filters.length === 0) {\n        return;\n      }\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        var filterFieldPath = filter.fieldPath._toPath();\n\n        for (var k = 0; k < this._orders.length; k++) {\n          var order = this._orders[k];\n          var orderFieldPath = order.fieldPath;\n\n          if (filter.operator === OPERATORS['==']) {\n            if (filterFieldPath === orderFieldPath) {\n              throw new Error(\"Invalid query. Query.orderBy() parameter: \" + orderFieldPath + \" cannot be the same as your Query.where() fieldPath parameter: \" + filterFieldPath);\n            }\n          }\n\n          if (filterFieldPath === _FirestoreFieldPath.DOCUMENT_ID._toPath() && orderFieldPath !== _FirestoreFieldPath.DOCUMENT_ID._toPath()) {\n            throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n          }\n\n          if (INEQUALITY[filter.operator]) {\n            if (filterFieldPath !== this._orders[0].fieldPath) {\n              throw new Error(\"Invalid query. Initial Query.orderBy() parameter: \" + orderFieldPath + \" has to be the same as the Query.where() fieldPath parameter(s): \" + filterFieldPath + \" when an inequality operator is invoked \");\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"filters\",\n    get: function get() {\n      return this._filters.map(function (f) {\n        return (0, _extends2.default)({}, f, {\n          fieldPath: f.fieldPath._toArray()\n        });\n      });\n    }\n  }, {\n    key: \"orders\",\n    get: function get() {\n      return this._orders;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var options = {};\n\n      if (this._limit) {\n        options.limit = this._limit;\n      }\n\n      if (this._limitToLast) {\n        options.limitToLast = this._limitToLast;\n      }\n\n      if (this._startAt) {\n        options.startAt = this._startAt;\n      }\n\n      if (this._startAfter) {\n        options.startAfter = this._startAfter;\n      }\n\n      if (this._endAt) {\n        options.endAt = this._endAt;\n      }\n\n      if (this._endBefore) {\n        options.endBefore = this._endBefore;\n      }\n\n      return options;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }]);\n  return FirestoreQueryModifiers;\n}();\n\nexports.default = FirestoreQueryModifiers;","map":{"version":3,"sources":["C:/Program Files/nodejs/ComeClosely/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"names":["OPERATORS","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","DIRECTIONS","asc","desc","FirestoreQueryModifiers","_limit","undefined","_limitToLast","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","newInstance","cursor","fields","limit","Math","floor","length","Error","limitToLast","operator","fieldPath","opStr","value","filter","concat","hasInequality","i","_toPath","hasArrayContains","hasArrayContainsAny","hasIn","directionStr","toLowerCase","order","direction","orders","map","$","set","Set","size","filterFieldPath","k","orderFieldPath","DOCUMENT_ID","f","_toArray","options","startAt","startAfter","endAt","endBefore"],"mappings":";;;;;;;;;;;;;;;AAiBA;;AACA;;AACA;;AAEA,IAAMA,SAAS,GAAG;AAChB,QAAM,OADU;AAEhB,OAAK,cAFW;AAGhB,QAAM,uBAHU;AAIhB,OAAK,WAJW;AAKhB,QAAM,oBALU;AAMhB,oBAAkB,gBANF;AAOhB,wBAAsB,oBAPN;AAQhBC,EAAAA,EAAE,EAAE;AARY,CAAlB;AAWA,IAAMC,UAAU,GAAG;AACjBC,EAAAA,SAAS,EAAE,IADM;AAEjBC,EAAAA,kBAAkB,EAAE,IAFH;AAGjBC,EAAAA,YAAY,EAAE,IAHG;AAIjBC,EAAAA,qBAAqB,EAAE;AAJN,CAAnB;AAOA,IAAMC,UAAU,GAAG;AACjBC,EAAAA,GAAG,EAAE,WADY;AAEjBC,EAAAA,IAAI,EAAE;AAFW,CAAnB;;IAKqBC,uB;AACnB,qCAAc;AAAA;AACZ,SAAKC,MAAL,GAAcC,SAAd;AACA,SAAKC,YAAL,GAAoBD,SAApB;AACA,SAAKE,QAAL,GAAgB,EAAhB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,KAAL,GAAa,YAAb;AAEA,SAAKC,QAAL,GAAgBL,SAAhB;AACA,SAAKM,WAAL,GAAmBN,SAAnB;AACA,SAAKO,MAAL,GAAcP,SAAd;AACA,SAAKQ,UAAL,GAAkBR,SAAlB;AACD;;;;4BAEO;AACN,UAAMS,WAAW,GAAG,IAAIX,uBAAJ,EAApB;AACAW,MAAAA,WAAW,CAACV,MAAZ,GAAqB,KAAKA,MAA1B;AACAU,MAAAA,WAAW,CAACR,YAAZ,GAA2B,KAAKA,YAAhC;AACAQ,MAAAA,WAAW,CAACP,QAAZ,oCAA2B,KAAKA,QAAhC;AACAO,MAAAA,WAAW,CAACN,OAAZ,oCAA0B,KAAKA,OAA/B;AACAM,MAAAA,WAAW,CAACL,KAAZ,GAAoB,KAAKA,KAAzB;AACAK,MAAAA,WAAW,CAACJ,QAAZ,GAAuB,KAAKA,QAA5B;AACAI,MAAAA,WAAW,CAACH,WAAZ,GAA0B,KAAKA,WAA/B;AACAG,MAAAA,WAAW,CAACF,MAAZ,GAAqB,KAAKA,MAA1B;AACAE,MAAAA,WAAW,CAACD,UAAZ,GAAyB,KAAKA,UAA9B;AACA,aAAOC,WAAP;AACD;;;oCAyCeC,M,EAAQC,M,EAAQ;AAC9B,iBAASD,MAAT,IAAqB,iCAAiBC,MAAjB,CAArB;AACA,aAAO,IAAP;AACD;;;+BAMU;AACT,aAAO,CAAC,EAAE,KAAKN,QAAL,IAAiB,KAAKC,WAAxB,CAAR;AACD;;;6BAEQ;AACP,aAAO,CAAC,EAAE,KAAKC,MAAL,IAAe,KAAKC,UAAtB,CAAR;AACD;;;6CAMwB;AACvB,WAAKJ,KAAL,GAAa,iBAAb;AACA,aAAO,IAAP;AACD;;;6CAEwB;AACvB,aAAO,KAAKA,KAAL,KAAe,iBAAtB;AACD;;;iCAMYQ,K,EAAO;AAClB,aAAO,CAAC,sBAASA,KAAT,CAAD,IAAoBC,IAAI,CAACC,KAAL,CAAWF,KAAX,MAAsBA,KAA1C,IAAmDA,KAAK,IAAI,CAAnE;AACD;;;0BAEKA,M,EAAO;AACX,WAAKX,YAAL,GAAoBD,SAApB;AACA,WAAKD,MAAL,GAAca,MAAd;AACA,aAAO,IAAP;AACD;;;uCAMkBA,K,EAAO;AACxB,aAAO,CAAC,sBAASA,KAAT,CAAD,IAAoBC,IAAI,CAACC,KAAL,CAAWF,KAAX,MAAsBA,KAA1C,IAAmDA,KAAK,IAAI,CAAnE;AACD;;;0CAEqB;AACpB,UAAI,KAAKX,YAAT,EAAuB;AACrB,YAAI,CAAC,KAAKE,OAAL,CAAaY,MAAlB,EAA0B;AACxB,gBAAM,IAAIC,KAAJ,CACJ,4IADI,CAAN;AAGD;AACF;AACF;;;gCAEWC,Y,EAAa;AACvB,WAAKlB,MAAL,GAAcC,SAAd;AACA,WAAKC,YAAL,GAAoBgB,YAApB;AACA,aAAO,IAAP;AACD;;;oCAMeC,Q,EAAU;AACxB,aAAO,CAAC,CAAC9B,SAAS,CAAC8B,QAAD,CAAlB;AACD;;;oCAEeA,Q,EAAU;AACxB,aAAO9B,SAAS,CAAC8B,QAAD,CAAT,KAAwB,OAA/B;AACD;;;iCAEYA,Q,EAAU;AACrB,aAAO9B,SAAS,CAAC8B,QAAD,CAAT,KAAwB,IAAxB,IAAgC9B,SAAS,CAAC8B,QAAD,CAAT,KAAwB,oBAA/D;AACD;;;0BAEKC,S,EAAWC,K,EAAOC,K,EAAO;AAC7B,UAAMC,MAAM,GAAG;AACbH,QAAAA,SAAS,EAATA,SADa;AAEbD,QAAAA,QAAQ,EAAE9B,SAAS,CAACgC,KAAD,CAFN;AAGbC,QAAAA,KAAK,EAAE,mCAAmBA,KAAnB;AAHM,OAAf;AAMA,WAAKnB,QAAL,GAAgB,KAAKA,QAAL,CAAcqB,MAAd,CAAqBD,MAArB,CAAhB;AACA,aAAO,IAAP;AACD;;;oCAEe;AACd,UAAIE,aAAJ;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,QAAL,CAAca,MAAlC,EAA0CU,CAAC,EAA3C,EAA+C;AAC7C,YAAMH,MAAM,GAAG,KAAKpB,QAAL,CAAcuB,CAAd,CAAf;;AAEA,YAAI,CAACnC,UAAU,CAACgC,MAAM,CAACJ,QAAR,CAAf,EAAkC;AAChC;AACD;;AAGD,YAAI,CAACM,aAAL,EAAoB;AAClBA,UAAAA,aAAa,GAAGF,MAAhB;AACA;AACD;;AAGD,YAAIhC,UAAU,CAACgC,MAAM,CAACJ,QAAR,CAAV,IAA+BM,aAAnC,EAAkD;AAChD,cAAIA,aAAa,CAACL,SAAd,CAAwBO,OAAxB,OAAsCJ,MAAM,CAACH,SAAP,CAAiBO,OAAjB,EAA1C,EAAsE;AACpE,kBAAM,IAAIV,KAAJ,2IACoIQ,aAAa,CAACL,SAAd,CAAwBO,OAAxB,EADpI,eAC+KJ,MAAM,CAACH,SAAP,CAAiBO,OAAjB,EAD/K,OAAN;AAGD;AACF;AACF;;AAED,UAAIC,gBAAJ;AACA,UAAIC,mBAAJ;AACA,UAAIC,KAAJ;;AAEA,WAAK,IAAIJ,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG,KAAKvB,QAAL,CAAca,MAAlC,EAA0CU,EAAC,EAA3C,EAA+C;AAC7C,YAAMH,OAAM,GAAG,KAAKpB,QAAL,CAAcuB,EAAd,CAAf;;AAEA,YAAIH,OAAM,CAACJ,QAAP,KAAoB9B,SAAS,CAAC,gBAAD,CAAjC,EAAqD;AACnD,cAAIuC,gBAAJ,EAAsB;AACpB,kBAAM,IAAIX,KAAJ,CAAU,qEAAV,CAAN;AACD;;AACDW,UAAAA,gBAAgB,GAAG,IAAnB;AACD;;AAED,YAAIL,OAAM,CAACJ,QAAP,KAAoB9B,SAAS,CAAC,oBAAD,CAAjC,EAAyD;AACvD,cAAIwC,mBAAJ,EAAyB;AACvB,kBAAM,IAAIZ,KAAJ,CACJ,0EADI,CAAN;AAGD;;AAED,cAAIa,KAAJ,EAAW;AACT,kBAAM,IAAIb,KAAJ,CACJ,+EADI,CAAN;AAGD;;AAEDY,UAAAA,mBAAmB,GAAG,IAAtB;AACD;;AAED,YAAIN,OAAM,CAACJ,QAAP,KAAoB9B,SAAS,CAACC,EAAlC,EAAsC;AACpC,cAAIwC,KAAJ,EAAW;AACT,kBAAM,IAAIb,KAAJ,CAAU,0DAAV,CAAN;AACD;;AAED,cAAIY,mBAAJ,EAAyB;AACvB,kBAAM,IAAIZ,KAAJ,CACJ,+EADI,CAAN;AAGD;;AAEDa,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;AACF;;;qCAMgBC,Y,EAAc;AAC7B,aAAO,CAAC,CAACnC,UAAU,CAACmC,YAAY,CAACC,WAAb,EAAD,CAAnB;AACD;;;4BAEOZ,S,EAAWW,Y,EAAc;AAC/B,UAAME,KAAK,GAAG;AACZb,QAAAA,SAAS,EAAEA,SAAS,CAACO,OAAV,EADC;AAEZO,QAAAA,SAAS,EAAEH,YAAY,GAAGnC,UAAU,CAACmC,YAAY,CAACC,WAAb,EAAD,CAAb,GAA4CpC,UAAU,CAACC;AAFlE,OAAd;AAKA,WAAKO,OAAL,GAAe,KAAKA,OAAL,CAAaoB,MAAb,CAAoBS,KAApB,CAAf;AACA,aAAO,IAAP;AACD;;;sCAEiB;AAEhB,UAAI,KAAK7B,OAAL,CAAaY,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAMmB,MAAM,GAAG,KAAK/B,OAAL,CAAagC,GAAb,CAAiB,UAAAC,CAAC;AAAA,iBAAIA,CAAC,CAACjB,SAAN;AAAA,SAAlB,CAAf;;AACA,YAAMkB,GAAG,GAAG,IAAIC,GAAJ,CAAQJ,MAAR,CAAZ;;AAEA,YAAIG,GAAG,CAACE,IAAJ,KAAaL,MAAM,CAACnB,MAAxB,EAAgC;AAC9B,gBAAM,IAAIC,KAAJ,CAAU,iEAAV,CAAN;AACD;AACF;;AAGD,UAAI,KAAKd,QAAL,CAAca,MAAd,KAAyB,CAA7B,EAAgC;AAC9B;AACD;;AAGD,WAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,QAAL,CAAca,MAAlC,EAA0CU,CAAC,EAA3C,EAA+C;AAC7C,YAAMH,MAAM,GAAG,KAAKpB,QAAL,CAAcuB,CAAd,CAAf;;AACA,YAAMe,eAAe,GAAGlB,MAAM,CAACH,SAAP,CAAiBO,OAAjB,EAAxB;;AAEA,aAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtC,OAAL,CAAaY,MAAjC,EAAyC0B,CAAC,EAA1C,EAA8C;AAC5C,cAAMT,KAAK,GAAG,KAAK7B,OAAL,CAAasC,CAAb,CAAd;AACA,cAAMC,cAAc,GAAGV,KAAK,CAACb,SAA7B;;AACA,cAAIG,MAAM,CAACJ,QAAP,KAAoB9B,SAAS,CAAC,IAAD,CAAjC,EAAyC;AAEvC,gBAAIoD,eAAe,KAAKE,cAAxB,EAAwC;AACtC,oBAAM,IAAI1B,KAAJ,gDACyC0B,cADzC,uEACyHF,eADzH,CAAN;AAGD;AACF;;AAED,cAAIA,eAAe,KAAKG,gCAAYjB,OAAZ,EAApB,IAA6CgB,cAAc,KAAKC,gCAAYjB,OAAZ,EAApE,EAA2F;AACzF,kBAAM,IAAIV,KAAJ,CACJ,iJADI,CAAN;AAGD;;AAED,cAAI1B,UAAU,CAACgC,MAAM,CAACJ,QAAR,CAAd,EAAiC;AAE/B,gBAAIsB,eAAe,KAAK,KAAKrC,OAAL,CAAa,CAAb,EAAgBgB,SAAxC,EAAmD;AACjD,oBAAM,IAAIH,KAAJ,wDACiD0B,cADjD,yEACmIF,eADnI,8CAAN;AAGD;AACF;AACF;AACF;AACF;;;wBAjRa;AACZ,aAAO,KAAKtC,QAAL,CAAciC,GAAd,CAAkB,UAAAS,CAAC;AAAA,0CAAUA,CAAV;AAAazB,UAAAA,SAAS,EAAEyB,CAAC,CAACzB,SAAF,CAAY0B,QAAZ;AAAxB;AAAA,OAAnB,CAAP;AACD;;;wBAEY;AACX,aAAO,KAAK1C,OAAZ;AACD;;;wBAEa;AACZ,UAAM2C,OAAO,GAAG,EAAhB;;AAEA,UAAI,KAAK/C,MAAT,EAAiB;AACf+C,QAAAA,OAAO,CAAClC,KAAR,GAAgB,KAAKb,MAArB;AACD;;AAED,UAAI,KAAKE,YAAT,EAAuB;AACrB6C,QAAAA,OAAO,CAAC7B,WAAR,GAAsB,KAAKhB,YAA3B;AACD;;AAED,UAAI,KAAKI,QAAT,EAAmB;AACjByC,QAAAA,OAAO,CAACC,OAAR,GAAkB,KAAK1C,QAAvB;AACD;;AACD,UAAI,KAAKC,WAAT,EAAsB;AACpBwC,QAAAA,OAAO,CAACE,UAAR,GAAqB,KAAK1C,WAA1B;AACD;;AACD,UAAI,KAAKC,MAAT,EAAiB;AACfuC,QAAAA,OAAO,CAACG,KAAR,GAAgB,KAAK1C,MAArB;AACD;;AACD,UAAI,KAAKC,UAAT,EAAqB;AACnBsC,QAAAA,OAAO,CAACI,SAAR,GAAoB,KAAK1C,UAAzB;AACD;;AAED,aAAOsC,OAAP;AACD;;;wBAEU;AACT,aAAO,KAAK1C,KAAZ;AACD","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nimport { DOCUMENT_ID } from './FirestoreFieldPath';\n\nconst OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({ ...f, fieldPath: f.fieldPath._toArray() }));\n  }\n\n  get orders() {\n    return this._orders;\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error(\n          'firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause',\n        );\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isInOperator(operator) {\n    return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY';\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    let hasInequality;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      // Set the first inequality\n      if (!hasInequality) {\n        hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && hasInequality) {\n        if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '${hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    let hasArrayContains;\n    let hasArrayContainsAny;\n    let hasIn;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\",\n          );\n        }\n\n        hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        hasIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath._toPath(),\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath);\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (this._filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}